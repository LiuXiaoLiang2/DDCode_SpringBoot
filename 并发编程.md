





1、展示线程之间交替执行

打印的顺序，也就是执行的顺序，是java底层的调度器来管控的，我们控制不了

![image-20220525102706422](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220525102706422.png)

![image-20220525104637144](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220525104637144.png)



方法执行完时，对应的栈帧也会消失，也就是内存被回收

可以清晰的看出，一个方法调用，就会生成一个栈帧，当方法调用完毕之后，栈帧也会被释放掉



java启动后的执行流程

1、类加载：将代码转换成字节码，存储到方法区中

2、main方法启动之后，内存就会给main方法分配一块栈内存用于执行，因为栈内存的作用就是用来执行线程的



P26：

Sleep写在哪个方法中，就是对哪个方法的睡眠

打印线程的状态， 方便的看到调用Sleep后，线程的状态变成了TIMEED_WAITING

![image-20220525113150841](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220525113150841.png)



# P26

打断睡眠的线程：调用interrupt 方法打断正在睡眠的线程

可以测试，打断睡眠的线程后，线程后面的代码仍然会被执行

这里要注意：睡眠结束后的线程未必会立刻得到执行

因为要等任务调度器给你分配了时间片，CPU才会去执行

专业词汇：线程醒了，不会立马获得CPU的执行权

![image-20220525113814179](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220525113814179.png)



可以调用TimeUnit调用Sleep方法



yield：
这个实现严重依赖操作系统的任务调度器

比如现在CPU很悠闲，你虽然调用了线程的yield方法，希望CPU去执行别的线程

但是CPU本来就没事干，CPU还是会执行你的线程，虽然你调用了yield方法，但是没有生效

也就是想让没让出去



Sleep和yield的区别

Sleep是让线程进入Timed Waiting 【阻塞状态】，Cpu是肯定不会执行的

yield是让线程进程就绪状态，也就是告诉CPU，我这个线程不着急执行，但是具体执行还是不执行，还是要看操作系统的任务调度器，也就是线程处于就绪状态，还是有可能分配到时间片



# p32 ：限制对CPU的使用

![image-20220526054937778](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220526054937778.png)





# p37：两阶段终止模式

![image-20220526062228537](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220526062228537.png)



不是让t2立马杀死，而是让t2有料理后事的机会

![image-20220526062528633](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220526062528633.png)

这里休眠2s是指：每隔2s执行一次监控，前面也有说到 在 while true 中 执行 sleep，可以很好的释放CPU

这里的有异常是指：如果在休眠的过程中，被其他线程打断，就会进入异常，但是休眠过程中被打断了，打断标记默认是被清除的，

就需要我们自己手动设置打断标记，这样在下次循环的时候，判断有没有被打断，就会判断的是 true

这里重新设置打断标记的技巧：重新在执行一次当前线程的 Interrupt 方法，这样下次循环的时候就可以终止子线程



子线程代码

![image-20220526063657904](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220526063657904.png)



主线程代码

![image-20220526063737004](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220526063737004.png)



# p42：park方法的使用

第二个方法【静态方法】，在判断以后，会清除标记

![image-20220526064713241](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220526064713241.png)



![image-20220526070006579](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220526070006579.png)

```
Thread.interrupted()
```

会清除打断标记，这样再次执行 park方法后，子线程还是会被挂起





# p43：守护线程

下面代码演示的是，不管是主线程还是子线程，只要有一个线程还在，那么java进程就不会结束

只有所有线程都结束了，java进程才会结束



下面代码主线程休眠1s就结束了

但是子线程一直在运行，子线程没有被打断



如果设置子线程为守护线程了

一旦主线程执行完毕了，守护线程立马结束，子线程后面的代码都不会执行，是被强制结束



![image-20220526071829459](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220526071829459.png)



# p48：泡茶代码

![image-20220526091831175](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220526091831175.png)

![image-20220526091724595](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220526091724595.png)





# 线程安全

![image-20220528105800405](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220528105800405.png)



可以看hashTable内部的put方法给加了 sysn锁



# Monitor

![image-20220530142805075](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220530142805075.png)



# wait和sleep的区别案例

sleep不会释放锁

![image-20220602104445065](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220602104445065.png)

wait会释放锁

![image-20220602104458970](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220602104458970.png)



# Park&UnPark的原理

![image-20220604085746075](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220604085746075.png)





# ReentrantLock的条件变量

![image-20220605093812010](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220605093812010.png)





犹豫模式

valicate 和 sync 的不同使用场景

![image-20220606092622577](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220606092622577.png)



# 懒汉模式1

![image-20220606100748767](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220606100748767.png)



缩小sync的作用范围



sync不能阻止指令重排，也就是sync包裹的代码也会存在指令重排，但是如果整个变量都被sync包裹了，那么就算发生了指令重排，也不会有有序性的问题



# 线程池



## submit时候

![image-20220610183213318](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220610183213318.png)

## invokeAll的使用

![image-20220610183719929](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220610183719929.png)



## invokeAny的使用

![image-20220610184146253](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220610184146253.png)



## shutdown ，不会阻塞主线程

![image-20220610190129801](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220610190129801.png)



# CompletableFuture学习1



## FutureTask的缺点



主线程调用get() 方法会一直阻塞等待，浪费资源



## CompletableFuture



### 简单使用

创建工具类

![image-20220613093142743](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613093142743.png)



创建CompletableFuture对象，开启新线程

返回的CompletableFuture对象，调用 join() 方法 ，是futureTask的get方法的升级版

也能阻塞等待返回子线程的返回值

![image-20220613093227817](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613093227817.png)



### thenCompose方法



![image-20220613093730486](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613093730486.png)



该方法有两个参数

![image-20220613093930948](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613093930948.png)

参数1：就是厨师线程的返回值，就是谁调用的 thenCompose方法，谁的返回值就是第一个参数

参数2：CompletionStage接口，其实就是 CompletableFuture的父类接口，所以我们又可以新建一个子线程任务

并且优点在于，我们可以在新建的子线程任务中，使用传入的第一个参数

总结：thenCompose的方法，是将前一个线程的运行结果作为参数传入到下一个线程中执行

注意：必须是前一个线程执行完毕了，由结果了，才会触发执行下一个线程的任务



### thenCombine方法



![image-20220613094641685](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613094641685.png)



可以看thenCombine的参数

![image-20220613094806124](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613094806124.png)

参数1：CompletionStage接口，其实就是 CompletableFuture的父类接口，所以我们又可以新建一个子线程任务

参数2：BiFunction函数时接口，传入两个参数，有返回值，这两个参数正好就是 厨师炒菜线程和服务员蒸饭线程的返回值，作为两个参数，内部可以通过这两个参数做数处理

同样的：要想执行 BiFunction函数 内部的方法，也是要等待 厨师炒菜线程和服务员蒸饭线程 都执行完了，有返回值了，才会触发执行

返回结果如下

![image-20220613095243634](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613095243634.png)



### 总结

![image-20220613095357966](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613095357966.png)

thenCombine用于连接两个任务



上面三个案例的任务模型

![image-20220613095551308](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613095551308.png)



### thenApply方法

应用场景：用于做任务的后续处理

![image-20220613100154762](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613100154762.png)

方法参数

![image-20220613100447619](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613100447619.png)

参数：Function函数接口，有一个入参，有一个返回值，参数就是前面任务的返回值，谁调用就是谁的返回值

注意：必须是前一个任务有返回值了才会触发thenApply方法

总结：就是将前面异步任务的结果交给后面的Function接口

打印

![image-20220613100903816](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613100903816.png)



但是发现个问题：服务员收款和开发票是一个线程，其实看代码，也能发现，肯定是一个线程，因为我们并没有新创建线程

那如何实现再开一个新线程，使用下面的方法

### thenApplyAsync方法



![image-20220613101735697](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613101735697.png)



这个时候打印，可以看到服务员收款和开发票是两个线程

![image-20220613101810447](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613101810447.png)



具体含义：是和上面的thenCompose方法是一样的

***有些场景有多种解决方式，选择自己擅长就好了***



### applyToEither方法

应用场景：哪个子线程先执行完。先返回哪个线程的结果



![image-20220613102241731](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613102241731.png)



参数含义

![image-20220613102351086](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613102351086.png)

参数1：CompletionStage接口，其实就是 CompletableFuture的父类接口，所以我们又可以新建一个子线程任务

参数2：Function函数接口，有一个入参，有返回值，具体的入参含义，就是两个线程任务谁先执行完，就将谁的线程返回值作为Function函数的入参，

只不过我们这里的Function函数内部代码没有做任何处理，直接将入参返回



### exceptionally方法



应用场景，专门用来处理子线程任务中出现异常的情况，可以保证最终任务就算有异常也有返回值

也就是链式调用的任何一步出现异常都会进入到exceptionally方法中

![image-20220613103341313](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613103341313.png)





## Async的使用



CompletableFuture的方法有以下特点

![image-20220613104242932](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613104242932.png)

大多数方法xxx(arg)，就是我们上面学的方法

都会对应有xxxAsync(arg) 和 xxxAsync(arg,Executor)两个方法

并且 xxxAsync(arg)和xxx(arg)的参数是一样的

xxxAsync(arg,Executor)比xxxAsync(arg) 多了一个 Executor



### xxxAsync(arg)



含义：就是开启一个新任务执行

使用我们之前用到的案例



### thenApply 和 thenApplyAsync

单纯的thenApply，就只是等上一个线程执行完后，将返回结果传入到thenApply方法，进行执行

很重要的一点是：执行thenApply的线程和上一个线程是同一个线程，所以再jvm看来，thenApply中的代码完全可以写道前一个线程中

![image-20220613105402517](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613105402517.png)

thenApplyAsync和thenApply的最大区别就是，执行thenApplyAsync内部方法是重新开启一个新线程执行

总结：调用了 xxxAsync，就会开启两个任务去执行

![image-20220613110158587](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613110158587.png)



### thenCompose和thenComposeAsync



thenCompose 方法：将上一个任务的返回值，传递到thenCompose 方法中作为参数

![image-20220613110421693](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613110421693.png)



将上面代码写的完整一些

就thenCompose而言，里面执行的代码时和前面的任务时同一个线程的

只不过，我们返回的对象是一个新的线程对象，所以在新的线程对象中内部方法，是新开线程的

![image-20220613111051501](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613111051501.png)



所以如果使用了thenComposeAsync后，thenComposeAsync方法内部代码就会又开一个新线程去执行

然后返回的对象又又是一个新线程对象





## supplyAsync和RunAsync

这两个方法都是 CompletableFuture的静态方法

runAsync：没有返回值

supplyAsync：有线程的返回值，通过调用 CompletableFuture 的 join方法获取



该方法是

![image-20220613111759981](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613111759981.png)



## 其他方法扩展



### thenApply的两个兄弟方法

thenApply是可以将上一个任务的返回值作为参数，传给thenApply方法中，并且该方法可以有返回值

thenApply方法的返回值，就是最后CompletableFuture调用join的返回值

![image-20220613112215685](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613112215685.png)



#### thenAccept方法

和thenApply相比而言，该方法使用的时Consumer函数式接口，有参数，没有返回值

所以如果需要的后续处理是，不需要返回的，就使用 thenAccept方法

![image-20220613112404532](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613112404532.png)



#### thenRun方法

和thenApply相比而言，该方法既没有参数，也没有返回值

![image-20220613112657315](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613112657315.png)



### thenCombine的两个兄弟方法



thenCombine方法的含义：两个任务并行执行。等两个任务都执行完，然后将两个任务的结果

传入到方法中，作为参数，方法内部可以进行数据处理，最后可以有返回值

这个返回值是最终CompletableFuture调用join的返回值

![image-20220613112833714](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613112833714.png)



#### thenAcceptBoth方法

得到两个任务的返回值作为参数，只是做数据处理，没有返回值

![image-20220613113802718](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613113802718.png)



#### thenAfterBoth方法

不关心前面两个线程的返回值，没有参数，也没有返回值，只是单独处理

![image-20220613113940137](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613113940137.png)



### applyToEither的两个兄弟方法



两个任务谁先执行完，将任务结果作为参数传给 applyToEither的第二个参数，可以做数据处理，进行返回

也就是该方法是有参数有返回值

![image-20220613114135007](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613114135007.png)



#### acceptToEither方法



会得到两个任务最快执行的返回结果，但是没有返回值

也就是有入参，没有返回值

![image-20220613114347138](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613114347138.png)



#### runAfterEither方法

不关心前两个任务谁执行的块，没有参数，也没有返回值，只是单独处理

![image-20220613114455189](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613114455189.png)



### exceptionally的两个兄弟方法



用于处理异常，参数是异常对象，有返回值，可以对异常进行修正，返回正常值

![image-20220613223600265](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613223600265.png)





#### handle方法

参数是BiFunction对象。也就是有两个参数

如果前面的链路执行没有异常，那么第一个参数就有值，就是前面链路的返回值

如果前面的链路有异常，那么第二个参数 exception就有值

无论如何都有返回值，让后面的程序继续执行

![image-20220613223803274](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613223803274.png)



#### whenComplate方法

和前面的handle方法类似，只不过是没有返回值

![image-20220613224106813](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613224106813.png)



## CompletableFuture性能



### 1、大量并发来了如何处理

学习使用 allOf方法

切记不可循环 join() ,那样就又变成了单线程

![image-20220613232021923](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613232021923.png)

![image-20220613231008306](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220613231008306.png)





# CompletableFuture学习2





## CompletableFuture的创建



业务场景

![image-20220614091038558](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614091038558.png)





runAsync：没有返回值

supplyAsync：有返回值

![image-20220614092845615](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614092845615.png)



这里使用get方法，也可以使用join方法

CompletableFuture中join()和get()方法的区别
一.相同点：
join()和get()方法都是用来获取CompletableFuture异步之后的返回值

二.区别：
join
join()方法抛出的是uncheck异常（即未经检查的异常),不会强制开发者强制捕捉，

会将异常包装成CompletionException异常 /CancellationException异常，但是本质原因还是代码内存在的真正的异常，



## CompletableFuture的回调



所谓回调就是对异步任务的后续处理，也就是异步任务完成之后，对异步任务返回数据或者异常的处理



比如下面使用的 whenComplateAsync，有两个参数

参数1：前面任务的返回值

参数2：异常信息对象，如果前面任务发生了异常，该对象就有值



![image-20220614094730931](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614094730931.png)



如果想要有返回值，后面可以继续加方法

加 execeptionally方法

参数：异常对象信息

返回值：最终CompletableFuture对象的返回值

![image-20220614095226234](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614095226234.png)



当然可以使用 handle方法，既能捕捉异常，又能有返回值

![image-20220614095912864](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614095912864.png)

这里要注意

这里 res 没拿到值得原因是：出现了 int i - 10 / 0，出现了异常，后面得返回就没有了



## CompletableFuture的串行方法



含义：任务1走完之后任务2才能走



也就是completableFuture的then方法



thenRunAsync方法

缺点：没有参数，没有返回值

![image-20220614100558254](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614100558254.png)





thenAcceptAsync方法

有参数，没有返回结果

参数：就是前一个任务的返回值



![image-20220614100959701](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614100959701.png)



thenApply方法

有参数，有返回结果

参数：前一个任务的返回值

返回结果：最终CompletableFuture对象的返回值



## 任务组合



### 两个任务都完成



背景：两个任务都完成后，再做后续处理

方法：runAfrerBothAsync



任务1

![image-20220614101905843](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614101905843.png)

任务2

![image-20220614101924477](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614101924477.png)



任务1调用runAfrerBothAsync方法

![image-20220614102001599](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614102001599.png)

最终结果：future1和future2都执行完了，才会执行lambda表达式中的任务3

缺点：没有参数， 没有返回值



thenAcceptBothAsync方法

和上面的一样，只不过有参数，没返回值

接收的参数：就是两个任务的返回值

![image-20220614102521205](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614102521205.png)



thenCombineAsync方法

和上面一样，只不过 有参数，有返回值

![image-20220614102714064](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614102714064.png)





### 有一个任务完成就行



背景：两个任务中只有有一个任务完成，就执行后续操作

runAfterEither方法

没有参数，没有返回值，只要有一个任务执行完就触发

![image-20220614103159093](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614103159093.png)



acceptToEither方法

有参数，没有返回值

参数：最快执行任务的返回值

![image-20220614103402010](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614103402010.png)



applyToEither方法

有参数，有返回值

参数：最快执行任务的返回值

返回值：最终CompletableFuture的返回值



### 多个任务的组合



#### 静态方法allof



多个任务都完成之后，再出发



![image-20220614104350196](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614104350196.png)



这里要注意，单纯调用 allof 方法是不会阻塞等待所有任务都并发执行完

需要调用 get 或者 join 方法才能阻塞等待，进而获取三个future的返回值



#### 静态方法anyof



多个任务只要有一个执行完了，就返回

![image-20220614104521625](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614104521625.png)



该方法的返回值就是最快执行的那个future





# ScheduledExecutor



## 延时执行

定时任务线程池

![image-20220614162337127](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614162337127.png)



虽然task1内部执行有延时

但是task1和task2是同时执行的，原因是我们设置的线程池对象是2

如果设置的是1，那么还是会串行执行



## 抛异常

出现异常，是否会影响下一个任务

![image-20220614162632497](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614162632497.png)



不会影响，就算我们设置的线程池核心线程数是1，让其串行执行，task1抛异常，是不会影响task2的



问题点：上面的异常并没有抛出，控制台没打印异常



自己手动try..catch

![image-20220614164921517](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614164921517.png)









## 定时执行



### scheduleAtFixedRate() 方法

![image-20220614163035793](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614163035793.png)



参数1：定时执行的方法

参数2：初始执行，也就是第一次执行的延时时间

参数3：周期执行的时间间隔

参数4：时间单位 秒



问题点：如果定时执行的方法内部耗时很长，超过了周期执行的时间间隔

![image-20220614163356172](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614163356172.png)

打印

![image-20220614163414751](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614163414751.png)

结果：第一次执行完了，才能执行第二遍，这样的好处就是不会重叠

但是第一次执行的时间已经都超过了设置的任务时间间隔，这个时候就忽略了设置的时间间隔，里面执行第二次任务

也就是参数3这个时间间隔，指的第二次任务开始  距离   第一次任务开始的时间间隔， 如果这个时间间隔超过了第一次任务的执行时长，那么第二次任务就会立即开始



### scheduleWithFiexdDelay()方法

![image-20220614163845585](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614163845585.png)



参数1：定时执行的方法

参数2：初始执行，也就是第一次执行的延时时间

参数3：周期执行的时间间隔 

参数4：时间单位 秒

也参数3这个时间间隔，指的第二次任务开始  距离   第一次任务结束的时间间隔， 

也就是说，不给任务1 什么时候结束，一旦他结束了，就要等设置好的时间间隔，才会执行第二次任务

打印

![image-20220614164802550](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614164802550.png)





# ForkJoin

## 1、创建任务对象

业务是：求1-n的和

![image-20220614170728230](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614170728230.png)



1、有返回值：继承 RecursiveTask<V>

2、没有返回值：继承 RecursiveAction 对象

![image-20220614170934529](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614170934529.png)





## 2、ForkJoin调用任务对象



创建forkPool线程池对象

无参的话，默认就是满线程，就是将线程打满

![image-20220614171417488](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614171417488.png)



## 3、完善任务对象

![image-20220614171510109](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220614171510109.png)





# 读写锁

![image-20220617102009042](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220617102009042.png)



二次检查的必要性

如果可能多个线程首次都没查询到数据，都会卡在写锁那里，多次检查可以保证就算多个写锁卡在那里，下一个写锁进去后，通过判断后，也不会查询数据库

读锁是可以并发的

如果有写锁，读锁可以卡住





# CyclicBarrier



![image-20220619095806487](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220619095806487.png)

可以循环使用

计数变为0后，再次使用的时候，又重新开始

![image-20220619095938467](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220619095938467.png)



存在的问题，就是如果线程池的数量和CyclicBarrier中定义的数量要一致

![image-20220619100220833](C:\Users\15810\AppData\Roaming\Typora\typora-user-images\image-20220619100220833.png)



